# lec5 SPOC思考题


NOTICE
- 有"w3l1"标记的题是助教要提交到学堂在线上的。
- 有"w3l1"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。


## 个人思考题
---

请简要分析最优匹配，最差匹配，最先匹配，buddy systemm分配算法的优势和劣势，并尝试提出一种更有效的连续内存分配算法 (w3l1)
```
  + 采分点：说明四种算法的优点和缺点
  - 答案没有涉及如下3点；（0分）
  - 正确描述了二种分配算法的优势和劣势（1分）
  - 正确描述了四种分配算法的优势和劣势（2分）
  - 除上述两点外，进一步描述了一种更有效的分配算法（3分）
 ```
- 最先匹配：
- 优点：按照地址排序，实现简单，而且在高地址处会有大块空闲内存可使用；
- 缺点：由于完全按照地址进行分配，在释放过一些内存块之后容易产生大量外部碎片，而且若是要分配大块内存，需要搜索至高地址位，所需时间较久。
- 最优匹配：
- 优点：由于按照分区大小从小到大排列，所以搜索到的区块就是比所需内存空间大得最少的空闲空间，即最优，可以避免大的空闲分区被拆分，减少外碎片的大小。
- 缺点：还是会产生大量外部碎片，而且由于碎片较小，会更难被合并、消除。另外由于按照分区大小排序，在释放空间时需要遍历空间查找是否有邻近的可合并的空间。
- 最差匹配：
- 优点：对于空间需求的大小适中时，效果最好，由于按照从大到小排序，每次分配都是在最大分区里分配，所以不容易出现小碎片。
- 缺点：同最优匹配一样，由于按照分区大小从小到大排列所以在释放合并空闲区间时较慢。也会产生外部碎片。另外由于优先分配最大的空间，容易导致后续不存在足够大的分区。
- 伴侣系统：
- 优点：极少的外碎片数量，快速的分配与释放。
- 缺点：由于分配量只能是2的幂次，所以对于在2^k~2^(k+1)之内的内存需求，最多可能浪费2^k-1的空间，即会存在大量的内碎片。
- 更有效的算法：
- 从linux采用基于伙伴系统的内存管理算法上来看，这是一种兼顾效率和速度的算法，所以我们可以考虑在这上面进行改进，即如何尽可能减少内碎片的量。
- 比如如果需要65KB的内存，我们会给他分配128KB，改进可以采取对空闲的63KB分为32KB+16KB+8KB+4KB+2KB+1KB，这样6个小的空闲区间，如此便可将内碎片的数量减至最小。至于这种方法可能带来的效率方面的降低，只能说是一种trade-off吧，到底是内存的空间资源更重要还是运行的时间资源更重要。

>  

## 小组思考题

请参考ucore lab2代码，采用`struct pmm_manager` 根据你的`学号 mod 4`的结果值，选择四种（0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm）分配算法中的一种或多种，在应用程序层面(可以 用python,ruby,C++，C，LISP等高语言)来实现，给出你的设思路，并给出测试用例。 (spoc)

```
如何表示空闲块？ 如何表示空闲块列表？ 
[(start0, size0),(start1,size1)...]
在一次malloc后，如果根据某种顺序查找符合malloc要求的空闲块？如何把一个空闲块改变成另外一个空闲块，或消除这个空闲块？如何更新空闲块列表？
在一次free后，如何把已使用块转变成空闲块，并按照某种顺序（起始地址，块大小）插入到空闲块列表中？考虑需要合并相邻空闲块，形成更大的空闲块？
如果考虑地址对齐（比如按照4字节对齐），应该如何设计？
如果考虑空闲/使用块列表组织中有部分元数据，比如表示链接信息，如何给malloc返回有效可用的空闲块地址而不破坏
元数据信息？
伙伴分配器的一个极简实现
http://coolshell.cn/tag/buddy
```
- 代码及测试样例：https://github.com/dc3671/ucore_lab/blob/d0fad14e994b9b9bcb4d4901618c42ced1e0ba25/related_info/lab2/first_fit_allocation.cpp
- 设计思路：空闲块及已用块分别用一个链表进行存储，空闲块按照地址顺序依次存储，已用块则无序，链表头存在pmm类里，链表每个节点为free_alloc/used_alloc类，存下一个节点和该块的起始地址和大小。pmm类实现了malloc和free方法。malloc时按照空闲块链表顺序进行查找，找到的第一个进行空间分割和分配，剩余的空间就替代原来节点即可。free时先在已用块链表里按首地址进行查找，找到之后再在空闲块链表里查找，对于当前空闲块和free块相邻的情况进行合并（直接修改空闲块节点的大小和首地址），当链表查找完或者当前空间块的首地址大于free块的首地址则退出循环，查找结束。

--- 

## 扩展思考题

阅读[slab分配算法](http://en.wikipedia.org/wiki/Slab_allocation)，尝试在应用程序中实现slab分配算法，给出设计方案和测试用例。

## “连续内存分配”与视频相关的课堂练习

### 5.1 计算机体系结构和内存层次
MMU的工作机理？

- [x]  

>  http://en.wikipedia.org/wiki/Memory_management_unit

L1和L2高速缓存有什么区别？

- [x]  

>  http://superuser.com/questions/196143/where-exactly-l1-l2-and-l3-caches-located-in-computer
>  Where exactly L1, L2 and L3 Caches located in computer?

>  http://en.wikipedia.org/wiki/CPU_cache
>  CPU cache

### 5.2 地址空间和地址生成
编译、链接和加载的过程了解？

- [x]  

>  

动态链接如何使用？

- [x]  

>  


### 5.3 连续内存分配
什么是内碎片、外碎片？

- [x]  

>  

为什么最先匹配会越用越慢？

- [x]  

>  

为什么最差匹配会的外碎片少？

- [x]  

>  

在几种算法中分区释放后的合并处理如何做？

- [x]  

>  

### 5.4 碎片整理
一个处于等待状态的进程被对换到外存（对换等待状态）后，等待事件出现了。操作系统需要如何响应？

- [x]  

>  

### 5.5 伙伴系统
伙伴系统的空闲块如何组织？

- [x]  

>  

伙伴系统的内存分配流程？

- [x]  

>  

伙伴系统的内存回收流程？

- [x]  

>  

struct list_entry是如何把数据元素组织成链表的？

- [x]  

>  



